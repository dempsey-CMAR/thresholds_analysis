---
title: "CMAR Data Governance:<br/>Quality Control of Water Quality Data"
format: 
  html:
    toc: true
    toc-depth: 3
    embed-resources: true
bibliography: references/cmp_threshold_references.bib
number-sections: true
editor_options: 
  chunk_output_type: console
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, dpi = 600, fig.width = 8)

library(docalcs)
library(dplyr)
library(DT)
library(here)
library(ggplot2)
library(leaflet)
library(lubridate)
library(plotly)
library(quarto)
library(RColorBrewer)
library(strings)
library(stringr)
library(readr)
library(tidyr)

theme_set(theme_light())

dt_options <- list(
      dom = 'ft',
      paging = FALSE,
      searching = TRUE,
      scrollY = "550px",
      pageLength = 500,
      columnDefs = list(list(className = 'dt-center', targets = "_all"))
)
 
# percent saturation data used for threshold analysis
# dat_sat <- import_strings_data(input_path = here("data-raw")) %>%
#   select(COUNTY, WATERBODY, STATION, TIMESTAMP, DEPTH, VARIABLE, VALUE, UNITS) %>%
#   mutate(
#     COUNTY = if_else(STATION == "Sandy Cove St. Marys", "Digby", COUNTY),
#     DEPTH = round(as.numeric(DEPTH)),
#     MONTH = month(TIMESTAMP),
#     YEAR = year(TIMESTAMP)
#   ) %>% 
#   filter(
#     VARIABLE == "Dissolved Oxygen", 
#     UNITS == "percent saturation",
#     !(STATION %in% c("Piper Lake", "Hourglass Lake", "0193", "Sissiboo")),
#     !(COUNTY == "Inverness" & DEPTH %in% c(8, 18, 28, 36) & VARIABLE == "Dissolved Oxygen"),
#     !(STATION == "Ram Island" &
#         TIMESTAMP > as_datetime("2021-10-10")
#       & TIMESTAMP < as_datetime("2021-11-15"))
#   )

# summarized data - from same dataset imported in above
dat_summary <- read_csv(
  here("data/summary_filtered_data.csv"), show_col_types = FALSE
) %>%
  filter(variable == "Dissolved Oxygen")

# station locations
st_locations <- read_csv(
  here("data/Station_Locations_2022-12-06.csv"), show_col_types = FALSE
) %>%
  mutate(
    STATION = case_when(
      STATION == "Sandy Cove St. Mary's" ~ "Sandy Cove St. Marys",
      STATION == "Larry's River" ~ "Larrys River",
      TRUE ~ STATION)
  )

# DO units for each station
do_units <- read_csv(here("data/do_units.csv"), show_col_types = FALSE)

st_locations <- st_locations %>%
  left_join(do_units, by = "STATION")

# gross range thresholds (sensors)
gr_thresholds <- read_csv(
  here("data/grossrange_thresholds.csv"), show_col_types = FALSE
)
  
```

**DRAFT `r Sys.Date()`**




```{r, fig-do-station-units}
#| label: fig-do-station-locations
#| fig-height: 7
#| fig-cap: Approximate location of stations with dissolved oxygen data. Marker size is proportional to the number of dissolved oxygen observations within the county. Five counties (Antigonish, Colchester, Pictou, Queens, and Richmond) only have one station with DO data.

# set up colour palette - need to interpolate with colorRampPalette
n_col = length(unique(st_locations$COUNTY))
getpal = colorRampPalette(brewer.pal(8, "Dark2"))
pal <- colorFactor(getpal(n_col), domain = unique(st_locations$COUNTY))

# join the station locations dataset with the number of obs from each station
st_locations_units <- st_locations %>% 
  rename(county = COUNTY, station = STATION) %>% 
  inner_join(
    dat_summary %>% 
      filter(group == "all_station") %>% 
      select(county, station, n, st_units = units),
    by = c("county", "station") 
  ) %>% 
  group_by(station) %>% 
  mutate(n = sum(n)) %>% 
  filter(st_units == "percent saturation") %>% # to remove duplicate rows from different units
  group_by(county) %>% 
  mutate(
    n_tot = sum(n),
    n_prop = round(n / sum(n), digits = 2),
    popup = paste(county, station, n_prop, sep = "</br>")
  ) %>% 
  ungroup() %>% 
  select(-st_units) 

# interactive map
leaflet(st_locations_units) %>% 
  addProviderTiles(providers$CartoDB.Positron) %>% 
  addCircleMarkers(
    data = filter(st_locations_units, do_units == "percent saturation"),
    lng = ~LONGITUDE, lat = ~LATITUDE, weight = 1,
    radius = ~n_prop * 25,
    color = ~pal(county),
    fillColor =  ~pal(county),
    popup = ~popup,
    fillOpacity = 0.5,
    group = "percent saturation"
  ) %>%
  addCircleMarkers(
    data = filter(st_locations_units, do_units == "percent saturation & mg/L"),
    lng = ~LONGITUDE, lat = ~LATITUDE, weight = 1,
    radius = ~n_prop * 25,
    color = ~pal(county),
    fillColor =  ~pal(county),
    popup = ~popup,
    fillOpacity = 0.5,
    group = "percent saturation & mg/L"
  ) %>% 
  addLayersControl(
    overlayGroups = c("percent saturation", "percent saturation & mg/L"),
    options = layersControlOptions(collapsed = FALSE)
  )
```




## Gross Range Test

### Sensor Threholds

The sensor thresholds were determined based on the associated manual (Table 3).

```{r}
gr_thresholds %>%
  filter(str_detect(variable, "dissolved_oxygen")) %>%
  mutate(
    units = if_else(sensor_type == "hobo do", "mg / L", "percent saturation"),
    `Sensor (link to spec sheet)` =
      paste0('<a  target=_blank href=', url, '>', sensor_type,'</a>')
  ) %>%
  select( `Sensor (link to spec sheet)`, sensor_min, sensor_max, units) %>%
  datatable(
    dt_options <- list(
      dom = 'ft',
      searching = FALSE,
      paging = FALSE,
      pageLength = 500,
      columnDefs = list(list(className = 'dt-center', targets = "_all"))
    ),
    rownames = FALSE, escape = FALSE,
    caption = "Table 3: Dissolved oxygen gross range thresholds as determined by sensor specifications."
  )
```

### User Thresholds

User thresholds were determined separately for percent saturation ($DO_{\%saturation}$) and concentration ($DO_{concentration}$). **Preliminary QC was applied to the DO observations prior to this analysis. Obvious outliers[^5] and suspected biofouling signals were removed, and data from freshwater and river stations were not considered. **

[^5]: e.g. data from Whycocomagh near or below the oxycline - this actually goes for the whole document. Move up higher OR use ALL data for the above  figures


#### Percent Saturation

```{r}
county_month <- dat_summary %>% 
  filter(group == "county_month", units == "percent saturation") %>% 
  mutate(month = month(month, label = TRUE))

county_gr <- county_month %>% 
  rename(mean_month = mean) %>% 
  group_by(county) %>%
  summarise(
    mean = round(mean(mean_month), digits = 3),
    stdev = round(sd(mean_month), digits = 3)
  )
```


::: panel-tabset

### @fig-do-n-obs-sat
```{r}
#| label: fig-do-n-obs-sat
#| fig-height: 8
#| fig-cap: The number of dissolved oxygen (percent saturation) observations in each county. 

county <- dat_summary %>%
  filter(group == "county", units == "percent saturation")

p  <- ggplot(county, aes(n, county)) +
  geom_col(
    position = position_dodge2(preserve = "single", reverse = TRUE, padding = 0)
  ) +
  scale_y_discrete(name = "", limits = rev) +
  scale_x_continuous("Number of Dissolved Oxygen (% saturation) Records")

ggplotly(p)

# county_month <- dat_summary %>% 
#   filter(group == "county_month", units == "percent saturation") %>% 
#   select(month, county, mean) %>% 
#   mutate(month = month(month, label = TRUE)) %>% 
#   pivot_wider(names_from = "county", values_from = mean) %>% 
#   rowwise(month) %>% 
#   mutate(
#     month_min = min(c_across(Annapolis:Yarmouth), na.rm = TRUE),
#     month_max = max(c_across(Annapolis:Yarmouth), na.rm = TRUE),
#     month_diff = month_max - month_min
#   )

```

### @fig-do-n-obs-county-month
```{r}
#| label: fig-do-n-obs-county-month
#| fig-height: 10
#| fig-cap: The number of dissolved oxygen observations (% saturation) in each month for each county.
#| fig-cap-location: top

p <- ggplot(county_month , aes(n, month)) +
  geom_col(
    position = position_dodge2(preserve = "single", reverse = TRUE, padding = 0)
  ) +
  scale_y_discrete(name = "", limits = rev) +
  scale_x_continuous("Number of Dissolved Oxygen Observations") +
  facet_wrap(~ county, ncol = 3) +
  theme(panel.spacing.y = unit(15, "lines"))

ggplotly(p)
```

**Remove this??**

For each county, the overall average $DO_{\%saturation}$ was calculated from the monthly climatology to give each month equal weight regardless of number of observations collected. The overall average values ranged from `r round(min(county_gr_sat$mean))` % for `r county_gr_sat[which(county_gr_sat$mean == min(county_gr_sat$mean)), "county"]$county` County to `r round(max(county_gr_sat$mean))` % for `r county_gr_sat[which(county_gr_sat$mean == max(county_gr_sat$mean)), "county"]$county` County. Note that Inverness only has data for June to September (months that typically have relatively high DO), while Antigonish is missing data from July to September (@fig-do-n-obs-county-month). The range of the remaining counties is approximately 6 %.


### Figure
```{r}
#| label: fig-do-county-mean
#| fig-height: 8
#| fig-cap: The mean and standard deviation of dissolved oxygen (percent saturation) in each county (based on the monthly means to account for the different number of observations in each month).
#| fig-cap-location: top

p <- ggplot(county_gr, aes(mean, county)) +
  geom_errorbar(
    aes(xmin = mean - stdev, xmax = mean + stdev), 
    width = 0, linewidth = 1, alpha = 0.75
  ) +
  geom_point(size = 3) +
  scale_y_discrete(name = "", limits = rev) +
  scale_x_continuous("Dissolved Oxygen (percent saturation)")

ggplotly(p)
```

### Table 1
```{r}
#| label: tbl-mean-county-month
#| tbl-cap: Summary statistics of dissolved oxygen observations by county. Mean and standard deviation are based on the climatology (monthly means) for each county.

county_gr %>% 
  select(county, mean, stdev) %>% 
  datatable(options = dt_options, rownames = FALSE)
```
:::




The data from all counties was therefore pooled together, and potential $DO_{\%saturation}$ user thresholds were calculated following equation (x). Three grouping methods were used to identify an appropriate mean and standard deviation on which to base the thresholds (@tbl-thresh-comp). 

First, the DO observations were grouped by calendar month to give equal weight to each month regardless of the number of observations (as described in section xx). The average DO for each month was calculated, and the $avg_{DO_{Sat}}$ and $stdev_{DO_{Sat}}$ were calculated from these values (). 

Second, the DO observations were grouped by county to give equal weight to each county regardless of the number of observations. Similar to the above, the average DO for each county was calculated, and the $avg_{DO_{Sat}}$ and $stdev_{DO_{Sat}}$ were calculated from these values ().
 
Finally, $avg_{DO_{Sat}}$ and $stdev_{DO_{Sat}}$ were calculated from all the observations. 

The percent of observations flagged for each set of thresholds was used to inform the final choice of user thresholds (@fig-histogram).

::: panel-tabset

### Table
```{r}
#| label: tbl-thresh-comp
#| tbl-cap: Summary statistics from three different methods of calculating the user thresholds. For "all data", the mean and stdev are calculated from all observations; for "month", the mean and stdev are based on the monthly means; for "county" the mean and stdev are based on the county means. user_min and user_max are the associated thresholds. percent_greater (percent_less) is the percent of observations used in the analysis that are greater (less) than user_max (user_min). percent_out is the percent of observations flagged.

dat_summary_sat <- dat_summary %>% 
  filter(units == "percent saturation")

thresh_all <- dat_summary_sat %>% 
  filter(group == "all_data") %>% 
  select(mean, stdev) %>% 
  mutate(user_min = mean - 3 * stdev, user_max = mean + 3 * stdev) 

thresh_month <- dat_summary_sat %>% 
  filter(group == "all_month") %>% 
  rename(mean_month = mean) %>% 
  summarise(mean = mean(mean_month), stdev = sd(mean_month)) %>% 
  mutate(user_min = mean - 3 * stdev, user_max = mean + 3 * stdev) 

thresh_county <- dat_summary_sat %>% 
  filter(group == "county") %>% 
  rename(mean_county = mean) %>% 
  summarise(mean = mean(mean_county), stdev = sd(mean_county)) %>% 
  mutate(user_min = mean - 3 * stdev, user_max = mean + 3 * stdev) 


thresh_summary <- dat_sat %>% 
  bind_cols(thresh_all) %>% 
  summarise(
    percent_greater = 100 * sum(VALUE  > user_max) / n(),
    percent_less = 100 * sum(VALUE < user_min) / n(),
    percent_out = 100 * (sum(VALUE > user_max) + sum(VALUE < user_min)) / n()
  ) %>% 
  bind_cols(thresh_all) %>% 
  select(
    mean, stdev, user_min, user_max, percent_greater, percent_less, percent_out
  ) %>%
  mutate(group = "all data") %>% 
  rbind(
    dat_sat %>% 
      bind_cols(thresh_month) %>% 
      summarise(
        percent_greater = 100 * sum(VALUE  > user_max) / n(),
        percent_less = 100 * sum(VALUE < user_min) / n(),
        percent_out = 100 * (sum(VALUE > user_max) + sum(VALUE < user_min)) / n()
      ) %>% 
      bind_cols(thresh_month) %>% 
      select(
        mean, stdev, user_min, user_max, percent_greater, percent_less, percent_out
      ) %>%
      mutate(group = "month")
  ) %>% 
  rbind(
    dat_sat %>% 
      bind_cols(thresh_county) %>% 
      summarise(
        percent_greater = 100 * sum(VALUE  > user_max) / n(),
        percent_less = 100 * sum(VALUE < user_min) / n(),
        percent_out = 100 * (sum(VALUE > user_max) + 
                               sum(VALUE < user_min)) / n()
      ) %>% 
      bind_cols(thresh_county) %>% 
      select(
        mean, stdev, user_min, user_max, percent_greater, percent_less, percent_out
      ) %>%
      mutate(group = "county")
  ) %>% 
  mutate(across(where(is.numeric), ~round(., 2))) 

rownames(thresh_summary) <- thresh_summary$group
thresh_summary <- select(thresh_summary, -group)

thresh_summary %>% 
  t() %>% 
  datatable(options = dt_options)

```

### Figure
```{r}
#| label: fig-histogram
#| fig-cap: Distribution of dissolved oxygen observations (binwidth = 2 %; preliminary quality control applied). Observations flagged with the thresholds based on monthly data are highlighted in light orange and dark orange. Observations flagged using the thresholds based on ungrouped data are highlighted in dark orange.

ggplot(dat_sat, aes(VALUE)) +
  annotate(
    "rect", fill = "#EDA247",
    ymin = -Inf, ymax = Inf, alpha = 0.75,
    xmin = -Inf, xmax = thresh_all$user_min
  ) +
  annotate(
    "rect", fill = "#EDA247", alpha = 0.25,
    ymin = -Inf, ymax = Inf,
    xmin = thresh_all$user_min, xmax = thresh_month$user_min
  ) +
    annotate(
    "rect", fill = "#EDA247",
    ymin = -Inf, ymax = Inf, alpha = 0.75,
    xmin = Inf, xmax = thresh_all$user_max
  ) +
  annotate(
    "rect", fill = "#EDA247", alpha = 0.25,
    ymin = -Inf, ymax = Inf,
    xmin = thresh_month$user_max, xmax = thresh_all$user_max
  ) +
  
  geom_histogram(
    aes(y = 100 * after_stat(count / sum(count))),
    binwidth = 2, col = "grey10", fill = "#B0E0E6"
  ) +
  geom_hline(yintercept = 0, colour = "grey10") +
  scale_y_continuous("Percent of Observations", expand = expansion(mult = c(0, 0.1))) +
  scale_x_continuous("Dissolved Oxygen (percent saturation)") +
  theme(
    panel.grid = element_blank(), 
    panel.border = element_rect(colour = "grey10")
  )
```


:::



### Climatology Test

Observations from all counties were pooled to calculate a single set of climatology thresholds. The $avg_{season}$ was calculated as the average of all observations in a given month, and $stdev_{season}$ was the associated standard deviation. 

For some months the climatology threshold will trigger a [Suspect/Of Interest flag]{style="color: #EDA247;"} before the Gross Range test (e.g., January - April); in other months, the Gross Range test will trigger the flag first (@fig-climatology-thresh).

::: panel-tabset

### Figure
```{r}
#| label: fig-climatology-thresh
#| fig-cap: Monthly dissolved oxygen mean +/- 1 standard deviation. Solid orange lines indicate the climatology thresholds; dashed organge lines indicate the grossrange user thresholds.

month <- dat_summary %>%
  filter(group == "all_month", units == "percent saturation") %>% 
  select(month, n, mean, stdev) %>% 
  mutate(user_min = mean - 3 * stdev, user_max = mean + 3 * stdev)

alpha <- 0.4
fill <- "orange"
col <- "orange"
linewidth <- 1
    
ggplot(month, aes(month(month, label = TRUE), mean)) +
  geom_ribbon(
    aes(month, ymin = user_min, ymax = user_max, xmin = -Inf, xmax = Inf), alpha = 0.25, 
    fill = "#009200", col = NA, 
  ) +
  geom_ribbon(
    aes(month, ymin = user_max, ymax = Inf), alpha = alpha,
    fill = fill, col = col, linewidth = linewidth
  ) +
  annotate(
    "rect", alpha = alpha*1.5,
    ymin = thresh_all$user_max, ymax = Inf, xmin = 1, xmax = 12,
    fill = fill, col = col, linewidth = linewidth, linetype = 2
  ) +
  geom_ribbon(
    aes(month, ymin = -Inf, ymax = user_min), alpha = alpha, 
    fill = fill, col = col, linewidth = linewidth, 
  ) +
  annotate(
    "rect",  alpha = alpha * 1.5,
    ymin = -Inf, ymax = thresh_all$user_min, xmin = 1, xmax = 12,
    fill = fill, col = col, linewidth = linewidth, linetype = 2
  ) +
  geom_point(size = 4, col = "grey20") +
  geom_errorbar(
    aes(ymin = mean - stdev, ymax = mean + stdev),
    width = 0, col = "grey20"
  ) +
  scale_x_discrete("Month") + 
  scale_y_continuous("Dissolved Oxygen (percent saturation)") 

```

### Table 4
```{r}
month %>% 
  select(-n) %>% 
  mutate(month = month(month, label = TRUE)) %>% 
   mutate(across(where(is.numeric), ~round(., 2))) %>% 
  datatable(rownames = FALSE, options = dt_options)
```

:::

`r knitr::knit_exit()`


```{r, export-thresholds}

# gross range
gr_out <- gr_thresholds %>% 
  #filter(variable == "temperature_degree_c") %>% 
  select(-url) %>% 
  mutate(county = NA) %>%  
  bind_rows(
    user_thresh %>% 
      select(county, variable, user_min, user_max) %>% 
      mutate(sensor_type = NA)
  ) %>% 
  pivot_longer(
    cols = c("sensor_min", "sensor_max", "user_min", "user_max"),
    names_to = "threshold", values_to = "threshold_value"
  ) %>% 
  filter(!is.na(threshold_value)) %>% 
  mutate(qc_test = "grossrange")

# climatology
clim_out <- clim_thresholds %>% 
  mutate(
    qc_test = "climatology", 
    variable = "temperature_degree_c",
    month = as.numeric(month)
    ) %>% 
  pivot_longer(
    cols = c("season_min", "season_max"),
    names_to = "threshold", values_to = "threshold_value"
  ) 
  
# combine and export
threshold_tables <- gr_out %>% 
  bind_rows(clim_out) %>% 
  select(qc_test, variable, county, sensor_type, month, threshold, threshold_value)

write_csv(threshold_tables, here("output/threshold_tables.csv"))

write_csv(
  threshold_tables, 
  "C:/Users/Danielle Dempsey/Desktop/RProjects/Packages/qaqcmar/data-raw/threshold_tables.csv"
)

```

-   Flag Colours
    -   [Pass]{style="color: #009200;"}
    -   [Not Evaluated]{style="color: #c4c1a5;"}
    -   [Suspect/Of Interest]{style="color: #EDA247;"}
    -   [Fail]{style="color: #DB4325;"}
    -   [Missing Data]{style="color: #5A5A5A;"}
    
    

